
// BuildXMLSheet.java
// Andrew Davison, ad@fivedots.coe.psu.ac.th, Dec. 2016

/* Extract data stored in <fnm>XML.txt line-by-line, and
   add as rows to a new spreadsheet.

   Used with files generated by ExtractXMLInfo.java

   Usage:
      > compile BuildXMLSheet.java

      > run BuildXMLSheet payXML.txt
      > run BuildXMLSheet clubsXML.txt
      > run BuildXMLSheet weatherXML.txt     // plenty of attributes
      > run BuildXMLSheet companyXML.txt
*/


import java.io.*;
import java.util.*;

import com.sun.star.lang.*;
import com.sun.star.frame.*;

import com.sun.star.sheet.*;
import com.sun.star.table.*;



public class BuildXMLSheet
{

  public static void main(String[] args)
  {
    if (args.length != 1) {
      System.out.println("Usage: run BuildXMLSheet <XML textfile>");
      return;
    }

    Object[][] data = getData(args[0]);
    Lo.printTable(args[0] + " data", data);

    XComponentLoader loader = Lo.loadOffice();
    XSpreadsheetDocument doc = Calc.createDoc(loader);
    if (doc == null) {
      System.out.println("Document creation failed");
      Lo.closeOffice();
      return;
    }
    GUI.setVisible(doc, true);
    Lo.delay(2000);
    XSpreadsheet sheet = Calc.getSheet(doc, 0);

    Calc.setArray(sheet, "A1", data);

    // Lo.saveDoc(doc, "createdSS.ods");
    Lo.waitEnter();
    Lo.closeDoc(doc);
    Lo.closeOffice();
  }  // end of main()



  private static Object[][] getData(String fnm)
  /* The array of data is built in two stages:
       1) a list of different size arrays is created, one
          array for each input line
       2) The list is converted into a 2D array of fixed size
          by padding out the row arrays with ""s
  */
  {
    int maxCols = 0;    // max number of columns across all rows

    // each input line is stored as an array inside a list
    ArrayList<Object[]> rows = new ArrayList<Object[]>();

    System.out.println("Reading data from " + fnm);
    try {
      BufferedReader br = new BufferedReader(new FileReader(fnm));
      String line;
      while ((line = br.readLine()) != null) {
         Object[] toks = splitLine(line);
             // read a line as an array of tokens (strings)
        if (toks.length > 0)
          rows.add(toks);
        if (toks.length > maxCols)
          maxCols = toks.length;
      }
    }
    catch(IOException e) {
      System.out.println("Could not read " + fnm);
      return null;
    }

    // convert list of different length arrays into fixed size 2D array
    Object[][] data = new Object[rows.size()][maxCols];
    for (int r = 0; r < rows.size(); r++) {
      Object[] row = rows.get(r);
      for (int c = 0; c < maxCols; c++) {
        if (c >= row.length)
          data[r][c] = "";   // pad out array row with empty strings (required by Office)
        else
          data[r][c] = row[c];
      }
    }
    return data;
  }  // end of getData()



  private static String[] splitLine(String ln)
  /* Convert a line into an array of tokens (words).
       Every two spaces at the start of a line become an empty string in the array.
       A doubly quoted string is treated as one word.
       A word ending with ':' or '=' has that character stripped off.
  */
  { ln += " "; // To detect last token when not quoted...

    boolean inQuote = false;
    boolean isIndenting = true;
    int numSpaces = 0;

    StringBuilder word = new StringBuilder();
    ArrayList<String> toks = new ArrayList<String>();

    for (int i = 0; i < ln.length(); i++) {
      char ch = ln.charAt(i);
      
      if (ch != ' ' && isIndenting)
        isIndenting = false;

      if (ch == ' ' && isIndenting) {
        numSpaces++;
        if (numSpaces%2 == 0)
          toks.add("");
      }
      else if (ch == '\"' || ch == ' ' && !inQuote) {
        if (ch == '\"')
          inQuote = !inQuote;
        if (!inQuote && word.length() > 0) {
          char lastCh = word.charAt(word.length()-1);
          if ((lastCh == ':') || (lastCh == '='))
            word.deleteCharAt(word.length()-1);
          toks.add(word.toString());
          word.delete(0, word.length());
        }
      } 
      else
        word.append(ch);
    }
    return toks.toArray(new String[toks.size()]);
  }  // end of splitLine()



}  // end of BuildXMLSheet class
